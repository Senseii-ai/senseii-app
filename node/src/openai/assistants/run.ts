// this file will handle the run related tasks and actions

import OpenAI from "openai";
import { createMessage } from "./threads";
import {
  RequiredActionFunctionToolCall,
  Run,
} from "openai/resources/beta/threads/runs/runs";
import { threadId } from "worker_threads";
import { Message } from "openai/resources/beta/threads/messages/messages";
import chalk from "chalk";
import { parseFunctionArguments } from "./utils";
import { IFunctionType, getSupportedFunctions } from "./functions";

const runStatus = {
  QUEUED: "queued",
  CANCELLING: "cancelling",
  IN_PROGRESS: "in_progress",
  REQUIRES_ACTION: "requires_action",
  COMPLETED: "completed",
};

// create a run after adding a message into the thread
export const addMessageAndCreateRun = async (
  threadId: string,
  message: string,
  client: OpenAI,
  assistantId: string
) => {
  try {
    const addedMessage = await createMessage(message, client, threadId);
    const run = await client.beta.threads.runs.create(threadId, {
      assistant_id: assistantId,
    });
    // TODO: implement responsePoller
    const messages = await responsePoller(run, client, threadId);
    if (messages.length > 0) {
      console.log(chalk.green("run succesful"));
      return messages;
    }
  } catch (error) {
    console.log(chalk.red("error adding message and creating run"));
    throw error;
  }
};

// createRun creates a run on a thread, expecting the message is already added to the thread.
export const createRun = async (
  threadId: string,
  client: OpenAI,
  assistantId: string
) => {
  try {
    const run = await client.beta.threads.runs.create(threadId, {
      assistant_id: assistantId,
    });
    // TODO: implement responsePoller
    const response = await responsePoller(run, client, threadId);
    if (response.length > 0) {
      return response;
    }
  } catch (error) {
    console.log(chalk.red("error creating run"));
    throw error;
  }
};

// this function runs and aggregates the output of all the tools that are requried to be run.
export const runTools = async (tools: RequiredActionFunctionToolCall[]) => {
  try {
    // get a list of all the supported functions in the system
    const supportedFunctions = getSupportedFunctions();
    for (const tool of tools) {
      const functionName = tool.function.name;
      // requested function is supported by the system. get the function name and run it.
      // TODO: Make it more typesafe
      if (functionName in supportedFunctions) {
        const functionDefinition: IFunctionType =
          supportedFunctions[functionName];
        const funcName = functionDefinition.name;
        const fun = functionDefinition.function();
      }
    }
  } catch (error) {
    console.error(chalk.red("error running tools"));
    throw error;
  }
};

// responsePoller polls for response to be generated by the assistnat.
const responsePoller = async (
  run: Run,
  client: OpenAI,
  threadId: string
): Promise<Message[]> => {
  try {
    const incompleteState = ["queued", "cancelling", "in_progress"];
    let messages: Message[] = [];
    while (incompleteState.includes(run.status)) {
      console.log("RUN STATUS", run.status);
      // wait for 1 second to poll again.
      await new Promise((resolve) => setTimeout(resolve, 1000));
      run = await client.beta.threads.runs.retrieve(threadId, run.id);
    }

    // check if tool call is needed
    if (run.status === "requires_action") {
      console.log("REQUIRES ACTION");
      // TODO: run tools
      // get an array of all the tool calls needed to be run in parallel.
      const toolsCalls = run.required_action?.submit_tool_outputs.tool_calls;
      // get the output of the tool here and continue the run
      const messages = await responsePoller(run, client, threadId);
    }

    // check if run is complete
    if (run.status === runStatus.COMPLETED) {
      console.log(chalk.green("RUN COMPLETED"));
      messages = (await client.beta.threads.messages.list(threadId)).data;
    }
    return messages;
  } catch (error) {
    console.log(chalk.red("error polling response"));
    throw error;
  }
};

// run function

// run tools
